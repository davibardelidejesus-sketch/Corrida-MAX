<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Subway Surf - Clone (HTML5)</title>
  <style>
    /* Reset básico */
    html,body{height:100%;margin:0;background:#87CEEB;display:flex;align-items:center;justify-content:center;font-family:Arial, Helvetica, sans-serif}
    #gameWrap{width:100%;max-width:900px;height:600px;background:linear-gradient(#87CEEB,#4ea0e6);box-shadow:0 10px 30px rgba(0,0,0,.25);border-radius:12px;overflow:hidden;position:relative}
    canvas{display:block;width:100%;height:100%}
    /* HUD */
    .hud{position:absolute;left:12px;top:12px;color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.6);font-weight:700}
    .rightHud{position:absolute;right:12px;top:12px;color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.6);font-weight:700}
    .btns{position:absolute;left:12px;bottom:12px;color:#fff}
    .small{font-size:13px;opacity:.95}
    /* simples instruções (mobile) */
    .instr{position:absolute;left:50%;bottom:12px;transform:translateX(-50%);color:#fff;font-weight:700}
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="gameCanvas" width="900" height="600"></canvas>
    <div class="hud" id="score">Pontos: 0</div>
    <div class="rightHud" id="coins">Moedas: 0</div>
    <div class="instr small">Seta cima = pular • Seta baixo = agachar • Toque/Swipe também</div>
  </div>

<script>
/*
  Subway Surf - Clone simples em HTML5 Canvas
  - Rodovias em 3 pistas
  - Obstáculos e moedas aparecem
  - Pular e agachar (slide)
  - A velocidade aumenta com o tempo
  - Controle por teclado e toque (swipe)
*/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;

// Lanes: 3 pistas verticais (x positions)
const LANES = 3;
let laneX = [];
const lanePadding = 80; // margem nas laterais
const laneGap = (W - lanePadding*2) / (LANES-1);
for(let i=0;i<LANES;i++) laneX.push(lanePadding + i*laneGap);

// Player
const player = {
  lane:1, // 0,1,2
  x: laneX[1],
  baseY: H - 140,
  y: H - 140,
  width: 48,
  height: 64,
  vy: 0,
  gravity: 0.9,
  jumpStrength: -16,
  sliding: false,
  slideTimer: 0,
  slideDuration: 380, // ms
  color: '#ff4757'
};

let lastTime = performance.now();
let spawnTimer = 0;
let spawnInterval = 900; // ms
let obstacles = [];
let coins = [];
let gameSpeed = 3; // velocidade inicial reduzida // base speed
let score = 0;
let coinCount = 0;
let running = true;
let distance = 0;

// Resize handler (keeps internal coords consistent but scales in CSS)
function resize() {
  // keep canvas internal size fixed to preserve gameplay layout
}
window.addEventListener('resize', resize);

// Obstacle factory
function spawnObstacle(){
  const lane = Math.floor(Math.random()*LANES);
  const type = Math.random() < 0.25 ? 'big' : 'small';
  const height = type === 'big' ? 100 : 60;
  obstacles.push({
    x: W + 60,
    lane,
    y: player.baseY + (player.height - height),
    width: type === 'big' ? 70 : 48,
    height: height,
    passed:false,
    color: '#2f3542'
  });
}

function spawnCoin(){
  const lane = Math.floor(Math.random()*LANES);
  coins.push({x:W+60,lane,y:player.baseY+20,width:24,height:24,collected:false});
}

// Input
const keys = {};
window.addEventListener('keydown', e=>{keys[e.key]=true;handleKey(e.key,true)});
window.addEventListener('keyup', e=>{keys[e.key]=false;handleKey(e.key,false)});

function handleKey(key,down){
  if(!down) return;
  if(key === 'ArrowLeft'){ if(player.lane>0) {player.lane--; player.x = laneX[player.lane];} }
  if(key === 'ArrowRight'){ if(player.lane<LANES-1){player.lane++; player.x = laneX[player.lane];} }
  if(key === 'ArrowUp' || key === 'w' || key === 'W'){ tryJump(); }
  if(key === 'ArrowDown' || key === 's' || key === 'S'){ startSlide(); }
}

// Touch / swipe support
let touchStartY = null;
let touchStartX = null;
canvas.addEventListener('touchstart', e=>{
  const t = e.touches[0];
  touchStartY = t.clientY; touchStartX = t.clientX;
});
canvas.addEventListener('touchend', e=>{
  const t = e.changedTouches[0];
  const dy = (touchStartY - t.clientY);
  const dx = (touchStartX - t.clientX);
  if(Math.abs(dy) > 40 && Math.abs(dy) > Math.abs(dx)){
    if(dy > 0) tryJump(); else startSlide();
  } else {
    // tap: move to next lane (right) if tap right half, else left
    const rect = canvas.getBoundingClientRect();
    const x = t.clientX - rect.left;
    if(x > rect.width/2){ if(player.lane<LANES-1){player.lane++; player.x = laneX[player.lane];} }
    else { if(player.lane>0){player.lane--; player.x = laneX[player.lane];} }
  }
});

function tryJump(){
  // only jump if on ground (y approximately baseY)
  if(Math.abs(player.y - player.baseY) < 6 && !player.sliding){ player.vy = player.jumpStrength; }
}
function startSlide(){
  if(Math.abs(player.y - player.baseY) < 6 && !player.sliding){ player.sliding = true; player.slideTimer = 0; }
}

// collision helpers
function rectsOverlap(a,b){
  return !(a.x > b.x + b.width || a.x + a.width < b.x || a.y > b.y + b.height || a.y + a.height < b.y);
}

// Game loop
function update(dt){
  if(!running) return;
  // speed increases slowly
  gameSpeed += dt * 0.0009; // aceleração mais lenta // small acceleration
  distance += gameSpeed * dt * 0.06; // arbitrary distance for scoring
  score = Math.floor(distance);
  document.getElementById('score').innerText = 'Pontos: ' + score;
  document.getElementById('coins').innerText = 'Moedas: ' + coinCount;

  // spawn
  spawnTimer += dt;
  if(spawnTimer > spawnInterval){
    spawnTimer = 0;
    // spawn obstacle or coin, sometimes both
    if(Math.random() < 0.7) spawnObstacle();
    if(Math.random() < 0.5) spawnCoin();
    // gradually lower interval
    spawnInterval = Math.max(480, spawnInterval - 6);
  }

  // update player physics
  player.vy += player.gravity;
  player.y += player.vy;
  if(player.y > player.baseY){ player.y = player.baseY; player.vy = 0; }

  if(player.sliding){ player.slideTimer += dt; if(player.slideTimer > player.slideDuration){ player.sliding = false; } }

  // update obstacles and coins
  obstacles.forEach(o=>{ o.x -= gameSpeed * dt * 0.12; });
  coins.forEach(c=>{ c.x -= gameSpeed * dt * 0.12; });
  // remove offscreen
  obstacles = obstacles.filter(o=> o.x + o.width > -100);
  coins = coins.filter(c=> c.x + c.width > -100 && !c.collected);

  // collisions
  const playerBox = getPlayerBox();
  for(let i=0;i<obstacles.length;i++){
    const o = obstacles[i];
    const obox = {x: o.x + (o.lane - player.lane)*(laneGap), y: o.y, width: o.width, height: o.height};
    // adjust obstacle x based on lane differences so obstacles are placed in lane x positions
    obox.x = o.x + (o.lane - 1)*laneGap - (LANES===3?0:0); // centralize spawn reference
    // The above is an approximation; instead we compute exact x from lane
    obox.x = o.x + (o.lane - 1)*laneGap; // o.x is base at right edge, add lane offset
    if(rectsOverlap(playerBox, obox)){
      // if sliding and obstacle is tall, let the player pass sometimes
      if(player.sliding && o.height > 70){
        // pass
      } else {
        gameOver();
      }
    }
  }
  for(let i=0;i<coins.length;i++){
    const c = coins[i];
    const cbox = {x:c.x + (c.lane - 1)*laneGap, y:c.y, width:c.width, height:c.height};
    if(rectsOverlap(playerBox, cbox)){
      coinCount++; c.collected = true;
    }
  }
}

function getPlayerBox(){
  const x = player.x - player.width/2;
  let h = player.sliding ? player.height * 0.6 : player.height;
  const y = player.y + (player.height - h);
  return {x: x, y: y, width: player.width, height: h};
}

function gameOver(){
  running = false;
  // show overlay
  setTimeout(()=>{
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#fff'; ctx.textAlign='center'; ctx.font='36px Arial';
    ctx.fillText('Game Over', W/2, H/2 - 10);
    ctx.font='18px Arial'; ctx.fillText('Toque / pressione R para reiniciar', W/2, H/2 + 26);
  }, 50);
}

window.addEventListener('keydown', e=>{ if(!running && (e.key === 'r' || e.key === 'R')) restart(); });

function restart(){
  obstacles = []; coins = []; score = 0; coinCount = 0; distance = 0; gameSpeed = 6; spawnInterval = 900; running = true; player.lane = 1; player.x = laneX[1]; player.y = player.baseY; player.vy = 0; player.sliding = false; animate();
}

// Rendering
function draw(){
  // clear
  ctx.clearRect(0,0,W,H);

  // ground
  const groundY = player.baseY + player.height + 10;
  ctx.fillStyle = '#2ecc71';
  ctx.fillRect(0, groundY, W, H - groundY);

  // draw rails / lanes (simple)
  for(let i=0;i<LANES;i++){
    const px = laneX[i];
    // draw rail behind
    ctx.fillStyle = 'rgba(0,0,0,0.05)';
    ctx.fillRect(px - 120, groundY - 22, 240, 10);
  }

  // draw obstacles
  obstacles.forEach(o=>{
    const ox = o.x + (o.lane - 1)*laneGap;
    ctx.fillStyle = o.color;
    ctx.fillRect(ox - o.width/2, o.y, o.width, o.height);
    // small highlight
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.fillRect(ox - o.width/2 + 6, o.y + 6, o.width - 12, 10);
  });

  // draw coins
  coins.forEach(c=>{
    if(c.collected) return;
    const cx = c.x + (c.lane - 1)*laneGap + c.width/2;
    const cy = c.y + c.height/2;
    ctx.beginPath(); ctx.arc(cx, cy, c.width/2, 0, Math.PI*2); ctx.fillStyle = '#f1c40f'; ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fillRect(cx-6, cy-6, 8, 4);
  });

  // draw player (simple rounded rect)
  const px = player.x;
  const py = player.y;
  const pw = player.width; const ph = player.sliding ? player.height * 0.6 : player.height;
  const pyAdj = py + (player.height - ph);
  roundRect(ctx, px - pw/2, pyAdj, pw, ph, 8, true, false, player.color);
  // eye
  ctx.fillStyle = '#222'; ctx.fillRect(px - 6, pyAdj + 12, 10, 6);

  // UI - score drawn at top left by DOM, but let's also show speed
  ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.fillRect(12,56,160,34);
  ctx.fillStyle = '#fff'; ctx.font = '14px Arial'; ctx.textAlign='left'; ctx.fillText('Vel: ' + Math.floor(gameSpeed), 18, 80);
}

function roundRect(ctx, x, y, w, h, r, fill, stroke, color){
  if(typeof r === 'undefined') r = 5;
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
  if(fill){ ctx.fillStyle = color || '#000'; ctx.fill(); }
  if(stroke){ ctx.stroke(); }
}

// Main animate
function animate(now){
  if(!now) now = performance.now();
  const dt = Math.min(40, now - lastTime); // ms, cap for stable physics
  lastTime = now;
  update(dt);
  draw();
  if(running) requestAnimationFrame(animate);
}

// Start game
player.x = laneX[player.lane];
player.y = player.baseY;
animate();

// helpful: keyboard quick restart message

// small polishing: center lanes if canvas width changes

</script>
</body>
</html>
