<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Corrida Max 3D - C√©u Azul Aprimorado</title>
  <style>
    /* Estilos do jogo (inalterados) */
    html,body{height:100%;margin:0;background:linear-gradient(#bfe9ff,#87CEEB 50%,#68b0dd 100%);font-family:Arial, Helvetica, sans-serif;overflow:hidden}
    #gameWrap{width:100%;height:100%;display:flex;align-items:center;justify-content:center;position:relative}
    #overlay{position:absolute;left:12px;top:12px;color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.6);font-weight:700;z-index:4}
    #rightHud{position:absolute;right:12px;top:12px;color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.6);font-weight:700;z-index:4}
    #instr{position:absolute;left:50%;bottom:18px;transform:translateX(-50%);color:#fff;font-weight:700;z-index:4;
           padding: 6px 12px; border-radius: 4px; background: rgba(0,0,0,0.3); font-size: 14px;}
    canvas{display:block}
    button{position:absolute;top:60px;left:12px;z-index:5;padding: 8px 12px; cursor: pointer; border: none; border-radius: 4px;}
    
    /* Novo bot√£o para controle de volume */
    #toggleMute{position:absolute;top:12px;left:50%;transform:translateX(-50%);z-index:5;padding: 8px 12px; cursor: pointer; border: none; border-radius: 4px; background: rgba(255, 255, 255, 0.8);}
  </style>
</head>
<body>
  <div id="gameWrap"></div>
  <div id="overlay">Pontos: <span id="score">0</span></div>
  <div id="rightHud">Moedas: <span id="coins">0</span></div>
  <div id="instr"> ‚Üê ‚Üí = trocar pista ‚Ä¢ ‚Üë = pular ‚Ä¢ ‚Üì = abaixar/slide ‚Ä¢ R = reiniciar</div>
  <button id="toggleCam">Mudar c√¢mera</button>
  <button id="toggleMute">üîä M√∫sica</button>
  
  <audio id="gameMusic" loop>
    <source src="trilha_sonora.mp3" type="audio/mpeg">
    Seu navegador n√£o suporta a tag de √°udio.
  </audio>

<script src="https://unpkg.com/three@0.156.0/build/three.min.js"></script>
<script>
/*
  Corrida Max 3D - Vers√£o Aprimorada com √Åudio
*/

const container = document.getElementById('gameWrap');
const scene = new THREE.Scene();

// --- CONFIGURA√á√ÉO DO AMBIENTE ---
const SKY_TOP = 0xBFE9FF;
const SKY_MID = 0x87CEEB;
const SKY_BOTTOM = 0x68B0DD;
scene.background = new THREE.Color(SKY_MID);
scene.fog = new THREE.Fog(new THREE.Color(SKY_MID), 30, 70);

const renderer = new THREE.WebGLRenderer({antialias:true, alpha:false});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
container.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 400);
let camMode = 0;
camera.position.set(0,4,8);
camera.lookAt(0,1,0);

// Lighting
const hemi = new THREE.HemisphereLight(SKY_TOP, 0x444444, 0.95);
scene.add(hemi);

const dir = new THREE.DirectionalLight(0xffffff, 0.8);
dir.position.set(-5,10,5);
dir.castShadow = true;
dir.shadow.camera.left = -40; dir.shadow.camera.right = 40; dir.shadow.camera.top = 40; dir.shadow.camera.bottom = -40;
scene.add(dir);

// Pista (agora cinza/asfalto com marca√ß√µes)
const trackWidth = 6;
const trackLength = 120;
const lanes = 3;
const laneSpacing = 2.8;
const laneX = [ -laneSpacing, 0, laneSpacing ];

const trackMat = new THREE.MeshStandardMaterial({color:0x4f4f4f, metalness:0.1, roughness:0.8});
const trackGeo = new THREE.PlaneGeometry(trackWidth, trackLength, 1, 1);
const track = new THREE.Mesh(trackGeo, trackMat);
track.rotation.x = -Math.PI/2;
track.position.z = trackLength/2 - 10;
track.receiveShadow = true;
scene.add(track);

// Faixas de divis√£o
const stripeGeo = new THREE.BoxGeometry(0.1, 0.05, 1.5);
const stripeMat = new THREE.MeshBasicMaterial({color: 0xf1f1f1}); 
for(let i=0;i<40;i++){ 
  const stripeL = new THREE.Mesh(stripeGeo, stripeMat);
  stripeL.position.set(-laneSpacing/2, 0.03, i * -4 + 50);
  scene.add(stripeL);
  const stripeR = new THREE.Mesh(stripeGeo, stripeMat);
  stripeR.position.set(laneSpacing/2, 0.03, i * -4 + 50);
  scene.add(stripeR);
}

// Terreno lateral (verde)
const sideMat = new THREE.MeshStandardMaterial({color:0x2ecc71, metalness:0.1, roughness:0.9});
const sideGeo = new THREE.PlaneGeometry(60, trackLength, 1, 1);
const sideL = new THREE.Mesh(sideGeo, sideMat);
sideL.rotation.x = -Math.PI/2;
sideL.position.set(-33, -0.01, trackLength/2 - 10);
sideL.receiveShadow = true;
scene.add(sideL);

const sideR = new THREE.Mesh(sideGeo, sideMat);
sideR.rotation.x = -Math.PI/2;
sideR.position.set(33, -0.01, trackLength/2 - 10);
sideR.receiveShadow = true;
scene.add(sideR);


// Player 
const player = {
  lane:1,
  mesh: null,
  width:0.9, height:1.4,
  vy:0, gravity:-30,
  jumping:false,
  sliding:false,
  slideTimer:0,
  slideDuration:0.45
};
const pGeo = new THREE.BoxGeometry(player.width, player.height, 0.9);
const pMat = new THREE.MeshStandardMaterial({color:0xff4757});
player.mesh = new THREE.Mesh(pGeo, pMat);
player.mesh.castShadow = true;
player.mesh.position.set(laneX[player.lane], player.height/2, 0);
scene.add(player.mesh);


// --- L√ìGICA DE NUVENS ---
function createCloudTexture(){
  const size = 256;
  const cv = document.createElement('canvas');
  cv.width = size; cv.height = size;
  const ctx = cv.getContext('2d');
  ctx.clearRect(0,0,size,size);
  const grd = ctx.createRadialGradient(128,128,10,128,128,120);
  grd.addColorStop(0, 'rgba(255,255,255,0.95)');
  grd.addColorStop(0.5, 'rgba(255,255,255,0.8)');
  grd.addColorStop(1, 'rgba(255,255,255,0.0)');
  ctx.fillStyle = grd;
  ctx.fillRect(0,0,size,size);
  ctx.globalCompositeOperation = 'lighter';
  for(let i=0;i<6;i++){
    const x = 40 + Math.random()*176;
    const y = 40 + Math.random()*176;
    const r = 30 + Math.random()*60;
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,255,' + (0.5 + Math.random()*0.5) + ')';
    ctx.arc(x,y,r,0,Math.PI*2);
    ctx.fill();
  }
  return new THREE.CanvasTexture(cv);
}
const clouds = [];
const cloudTex = createCloudTexture();
function makeCloud(scale=1){
  const mat = new THREE.MeshBasicMaterial({map: cloudTex, transparent:true, depthWrite:false, opacity:0.95});
  const geo = new THREE.PlaneGeometry(12*scale, 8*scale);
  const mesh = new THREE.Mesh(geo, mat);
  mesh.rotation.y = Math.PI/8;
  mesh.renderOrder = 0;
  mesh.position.set((Math.random()-0.5)*60, 18 + Math.random()*6, -20 + Math.random()*80);
  mesh.material.opacity = 0.9 - Math.random()*0.3;
  scene.add(mesh);
  return mesh;
}
for(let i=0;i<10;i++){ clouds.push(makeCloud(0.6 + Math.random()*1.6)); }


// --- OBST√ÅCULOS E MOEDAS ---
function makeObstacle(type=0){
  const h = type===1 ? 1.6 : 1.0;
  const g = new THREE.BoxGeometry(1.2, h, 1.2);
  const m = new THREE.MeshStandardMaterial({color: type===1 ? 0x9b59b6 : 0x2f3542});
  const mesh = new THREE.Mesh(g,m);
  mesh.castShadow = true;
  const lane = Math.floor(Math.random()*lanes);
  mesh.position.set(laneX[lane], h/2, 40);
  scene.add(mesh);
  return {mesh, lane, width:1.2, height:h, passed:false, type: type};
}

function makeCoin(){
  const g = new THREE.SphereGeometry(0.35,12,12);
  const m = new THREE.MeshStandardMaterial({color:0xf1c40f, metalness:0.8, roughness:0.2});
  const mesh = new THREE.Mesh(g,m);
  mesh.castShadow = true;
  const lane = Math.floor(Math.random()*lanes);
  mesh.position.set(laneX[lane], 1.0, 40);
  scene.add(mesh);
  return {mesh, lane, collected:false};
}

let obstacles = [];
let coins = [];
let spawnTimer = 0;
let spawnInterval = 1.1;
let clock = new THREE.Clock();

let gameSpeed = 6;
let distance = 0;
let score = 0;
let coinCount = 0;
let running = true;


// --- √ÅUDIO (NOVO) ---
const gameMusic = document.getElementById('gameMusic');
let isMuted = false;

// Tenta tocar a m√∫sica assim que houver a primeira intera√ß√£o do usu√°rio (clique/tecla)
function tryPlayMusic(){
    if (gameMusic.paused && !isMuted) {
        gameMusic.play().catch(error => {
            // Se falhar (e.g., autoplay bloqueado), tentaremos novamente na pr√≥xima intera√ß√£o.
            console.log("Autoplay bloqueado. A m√∫sica iniciar√° no pr√≥ximo clique/tecla.");
        });
    }
}

document.getElementById('toggleMute').addEventListener('click', ()=>{ 
    isMuted = !isMuted;
    gameMusic.muted = isMuted;
    document.getElementById('toggleMute').innerText = isMuted ? 'üîá M√∫sica' : 'üîä M√∫sica';
    if (!isMuted) {
        tryPlayMusic();
    }
});

// Adiciona o tryPlayMusic em qualquer intera√ß√£o do jogo
window.addEventListener('keydown', tryPlayMusic);
renderer.domElement.addEventListener('touchstart', tryPlayMusic);
document.getElementById('toggleCam').addEventListener('click', tryPlayMusic);
document.getElementById('toggleMute').addEventListener('click', tryPlayMusic);
// FIM √ÅUDIO NOVO


// --- FUN√á√ïES DE INPUT E MOVIMENTO ---
const keys = {};
window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()]=true; handleKey(e.key.toLowerCase()); });
window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()]=false; });

function handleKey(k){
  if(!running){
    if(k === 'r') location.reload();
    return;
  }
  if(k === 'arrowleft' || k === 'a'){ if(player.lane>0){ player.lane--; } }
  if(k === 'arrowright' || k === 'd'){ if(player.lane<lanes-1){ player.lane++; } }
  if(k === 'arrowup' || k === 'w'){ tryJump(); }
  if(k === 'arrowdown' || k === 's'){ startSlide(); }
}

function tryJump(){
  if(!player.jumping && !player.sliding){
    player.vy = 10; player.jumping = true;
  }
}
function startSlide(){
  if(!player.jumping && !player.sliding){
    player.sliding = true; player.slideTimer = 0;
    player.mesh.scale.set(1, 0.6, 1);
    player.mesh.position.y = player.height * 0.6 / 2;
  }
}
function endSlide(){
  player.sliding = false;
  player.mesh.scale.set(1, 1, 1);
  player.mesh.position.y = player.height/2;
}


// --- TOUCH CONTROLS ---
let tStartY = null, tStartX = null;
renderer.domElement.addEventListener('touchstart', e=>{
  const t = e.touches[0];
  tStartY = t.clientY; tStartX = t.clientX;
});
renderer.domElement.addEventListener('touchend', e=>{
  const t = e.changedTouches[0];
  const dy = tStartY - t.clientY, dx = tStartX - t.clientX;
  if(Math.abs(dy) > 40 && Math.abs(dy) > Math.abs(dx)){
    if(dy > 0) tryJump(); else startSlide();
  } else if (Math.abs(dx) > 40) {
    const rect = renderer.domElement.getBoundingClientRect();
    const x = t.clientX - rect.left;
    if(x > rect.width/2) { if(player.lane<lanes-1) player.lane++; }
    else { if(player.lane>0) player.lane--; }
  }
});


// --- GAME LOOP ---
function update(dt){
  if(!running) return;

  // Aumento de velocidade
  gameSpeed = Math.min(20, gameSpeed + dt * 0.02);

  // Spawn
  spawnTimer += dt;
  if(spawnTimer > spawnInterval){
    spawnTimer = 0;
    if(Math.random() < 0.7){
      const type = Math.random()<0.3?1:0;
      obstacles.push(makeObstacle(type));
    }
    if(Math.random() < 0.4){
      coins.push(makeCoin());
    }
    spawnInterval = Math.max(0.5, spawnInterval - 0.005);
  }

  // Atualiza√ß√£o Vertical do Jogador
  if(player.jumping){
    player.vy += player.gravity * dt;
    player.mesh.position.y += player.vy * dt;
    if(player.mesh.position.y <= player.height/2){
      player.mesh.position.y = player.height/2;
      player.jumping = false; player.vy = 0;
    }
  } else {
    if(!player.sliding) {
      player.mesh.position.y = player.height/2;
    }
  }

  if(player.sliding){
    player.slideTimer += dt;
    if(player.slideTimer > player.slideDuration){
      endSlide();
    }
  }

  // Movimento Suave da Faixa
  const targetX = laneX[player.lane];
  player.mesh.position.x += (targetX - player.mesh.position.x) * Math.min(1, 15*dt);

  // Movimento de Obst√°culos/Moedas e Colis√£o
  const moveZ = gameSpeed * dt;
  
  // Obst√°culos
  for(let i=obstacles.length-1;i>=0;i--){
    const o = obstacles[i];
    o.mesh.position.z -= moveZ;
    if(o.mesh.position.z < -5){
      scene.remove(o.mesh); obstacles.splice(i,1); continue;
    }
    
    // Colis√£o (AABB simplificada)
    if(Math.abs(o.mesh.position.z - player.mesh.position.z) < 1.0 && o.lane === player.lane){
      
      let avoided = false;
      
      // Objeto Baixo (type 0) deve ser pulado ou evitado
      if(o.type === 0 && player.jumping) avoided = true; 
      
      // Objeto Alto (type 1) deve ser deslizado ou pulado muito alto
      if(o.type === 1 && player.sliding) avoided = true;
      if(o.type === 1 && player.jumping && player.mesh.position.y > o.height) avoided = true;

      if(!avoided){
        endGame();
      }
    }
  }
  
  // Moedas
  for(let i=coins.length-1;i>=0;i--){
    const c = coins[i];
    c.mesh.position.z -= moveZ;
    c.mesh.rotation.y += 5 * dt;
    if(c.mesh.position.z < -5){ scene.remove(c.mesh); coins.splice(i,1); continue; }
    
    // Colis√£o (Coleta)
    if(Math.abs(c.mesh.position.z - player.mesh.position.z) < 1.0 && c.lane === player.lane){
      coinCount++; document.getElementById('coins').innerText = coinCount;
      scene.remove(c.mesh); coins.splice(i,1);
    }
  }

  // Pontua√ß√£o e HUD
  distance += gameSpeed * dt;
  score = Math.floor(distance);
  document.getElementById('score').innerText = score;

  // Atualiza√ß√£o das nuvens
  for(let i=0;i<clouds.length;i++){
    const c = clouds[i];
    c.position.x += Math.sin((performance.now()*0.0001)+i) * dt * 0.4;
    c.position.z -= dt * 0.8;
    if(c.position.z < -30) c.position.z = 80 + Math.random()*30;
    if(c.position.x > 40) c.position.x = -40;
    if(c.position.x < -40) c.position.x = 40;
  }
}

function endGame(){
  running = false;
  gameMusic.pause(); // Para a m√∫sica
  
  // Feedback visual de colis√£o
  camera.position.y += 0.5;
  player.mesh.material.color.set(0xff0000);
  
  const overlay = document.createElement('div');
  overlay.style.position = 'absolute';
  overlay.style.left = '0';
  overlay.style.top = '0';
  overlay.style.width = '100%';
  overlay.style.height = '100%';
  overlay.style.display = 'flex';
  overlay.style.alignItems = 'center';
  overlay.style.justifyContent = 'center';
  overlay.style.background = 'rgba(0,0,0,0.7)';
  overlay.style.color = '#fff';
  overlay.style.fontSize = '36px';
  overlay.style.textAlign = 'center';
  overlay.style.zIndex = 10;
  overlay.innerHTML = `<div>
    <h1 style="margin-bottom:0;">GAME OVER</h1>
    <p style="font-size: 20px;">Score Final: ${score} - Moedas: ${coinCount}</p>
    <small>Pressione R para reiniciar</small>
  </div>`;
  document.body.appendChild(overlay);
}

// --- ANIMA√á√ÉO E C√ÇMERA ---
function animate(){
  const dt = clock.getDelta();
  update(dt);
  
  const rotationZ = (player.mesh.position.x - laneX[player.lane]) * 0.05;

  if(camMode===0){
    camera.position.lerp(new THREE.Vector3(player.mesh.position.x, player.mesh.position.y + 2.5, player.mesh.position.z + 8), 0.08);
    camera.lookAt(player.mesh.position.x, player.mesh.position.y + 0.8, player.mesh.position.z);
    camera.rotation.z += (rotationZ - camera.rotation.z) * 0.2;

  } else {
    camera.position.lerp(new THREE.Vector3(0,12,28), 0.06);
    camera.lookAt(0,0,0);
    camera.rotation.z += (-camera.rotation.z) * 0.1;
  }

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

// --- EVENTOS GLOBAIS ---
window.addEventListener('resize', ()=>{ renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); });
document.getElementById('toggleCam').addEventListener('click', ()=>{ camMode = 1-camMode; });

// Inicializar obst√°culos e moedas √† frente
for(let i=0;i<4;i++){ 
  if(Math.random()<0.6) obstacles.push(makeObstacle(Math.random()<0.3?1:0)); 
  if(Math.random()<0.4) coins.push(makeCoin()); 
}

</script>
</body>
</html>
